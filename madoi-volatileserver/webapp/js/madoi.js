(function(d,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(d=typeof globalThis<"u"?globalThis:d||self,p(d.madoi={}))})(this,function(d){"use strict";var K=Object.defineProperty;var X=(d,p,v)=>p in d?K(d,p,{enumerable:!0,configurable:!0,writable:!0,value:v}):d[p]=v;var f=(d,p,v)=>X(d,typeof p!="symbol"?p+"":p,v);const p={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},v={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},b={sender:"__PEER__",recipients:void 0};function _(s=void 0){return{type:"Ping",...p,body:s}}function O(s){return{type:"EnterRoom",...p,...s}}function U(s){return{type:"LeaveRoom",...p,...s}}function R(s){return{type:"UpdateRoomProfile",...v,...s}}function S(s){return{type:"UpdatePeerProfile",...v,...s}}function C(s){return{type:"DefineFunction",...p,...s}}function D(s){return{type:"DefineObject",...p,...s}}function T(s,r){return{type:"InvokeFunction",castType:s,...b,...r}}function j(s){return{type:"UpdateObjectState",...p,...s}}function L(s,r){return{type:"InvokeMethod",castType:s,...b,...r}}class I extends EventTarget{addEventListener(...r){super.addEventListener(...r)}removeEventListener(...r){super.removeEventListener(...r)}dispatchCustomEvent(r,e){return super.dispatchEvent(new CustomEvent(r,{detail:e}))}}function $(s={}){return r=>{r.madoiClassConfig_=s}}const M={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function k(s=M){const r=s;return r.type||(r.type="beforeExec"),r.maxLog||(r.maxLog=0),(e,t,n)=>{const o={share:r};e[t].madoiMethodConfig_=o}}const E={maxInterval:5e3};function F(s=E){const r=s;return(e,t,n)=>{const o={getState:r};e[t].madoiMethodConfig_=o}}function N(s={}){const r=s;return(e,t,n)=>{const o={setState:r};e[t].madoiMethodConfig_=o}}function H(s={}){return(r,e,t)=>{const o={hostOnly:s};r[e].madoiMethodConfig_=o}}function x(s={}){const r=s;return(e,t,n)=>{const o={beforeEnterRoom:r};e[t].madoiMethodConfig_=o}}function B(s={}){const r=s;return(e,t,n)=>{const o={enterRoomAllowed:r};e[t].madoiMethodConfig_=o}}function J(s={}){const r=s;return(e,t,n)=>{const o={enterRoomDenied:r};e[t].madoiMethodConfig_=o}}function G(s={}){const r=s;return(e,t,n)=>{const o={leaveRoomDone:r};e[t].madoiMethodConfig_=o}}function Q(s={}){const r=s;return(e,t,n)=>{const o={roomProfileUpdated:r};e[t].madoiMethodConfig_=o}}function z(s={}){const r=s;return(e,t,n)=>{const o={peerEntered:r};e[t].madoiMethodConfig_=o}}function q(s={}){const r=s;return(e,t,n)=>{const o={peerLeaved:r};e[t].madoiMethodConfig_=o}}function V(s={}){const r=s;return(e,t,n)=>{const o={peerProfileUpdated:r};e[t].madoiMethodConfig_=o}}class W extends I{constructor(e,t,n,o){super();f(this,"connecting",!1);f(this,"interimQueue");f(this,"sharedFunctions",new Map);f(this,"sharedObjects",new Map);f(this,"sharedMethods",new Map);f(this,"getStateMethods",new Map);f(this,"setStateMethods",new Map);f(this,"beforeEnterRoomMethods",new Map);f(this,"enterRoomAllowedMethods",new Map);f(this,"enterRoomDeniedMethods",new Map);f(this,"leaveRoomDoneMethods",new Map);f(this,"roomProfileUpdatedMethods",new Map);f(this,"peerEnteredMethods",new Map);f(this,"peerLeavedMethods",new Map);f(this,"peerProfileUpdatedMethods",new Map);f(this,"url");f(this,"ws",null);f(this,"room",{id:"",spec:{maxLog:1e3},profile:{}});f(this,"selfPeer",{id:"",order:-1,profile:{}});f(this,"peers",new Map);f(this,"currentSender",null);f(this,"systemMessageTypes",["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"]);o&&(this.room={...this.room,...o}),n&&(this.selfPeer={...this.selfPeer,...n,order:-1}),this.interimQueue=new Array;const i=e.indexOf("?")!=-1?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${i}authToken=${t}`,this.room.id=e.split("rooms/")[1].split("?")[0];else{const a=document.querySelector("script[src$='madoi.js']").src.split("/",5),h=(a[0]=="http:"?"ws:":"wss:")+"//"+a[2]+"/"+a[3];this.url=`${h}/rooms/${e}${i}authToken=${t}`,this.room.id=e}this.ws=new WebSocket(this.url),this.ws.onopen=a=>this.handleOnOpen(a),this.ws.onclose=a=>this.handleOnClose(a),this.ws.onerror=a=>this.handleOnError(a),this.ws.onmessage=a=>this.handleOnMessage(a),setInterval(()=>{this.saveStates()},1e3),setInterval(()=>{this.sendPing()},3e4)}getRoomId(){return this.room.id}getRoomProfile(){var e;return(e=this.room)==null?void 0:e.profile}setRoomProfile(e,t){const n={};n[e]=t,this.sendMessage(R({updates:n}))}removeRoomProfile(e){this.sendMessage(R({deletes:[e]}))}getSelfPeerId(){var e;return(e=this.selfPeer)==null?void 0:e.id}getSelfPeerProfile(){return this.selfPeer.profile}updateSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const n={};n[e]=t,this.sendMessage(S({updates:n}))}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(S({deletes:[e]}))}getCurrentSender(){return this.currentSender?this.peers.get(this.currentSender):null}isCurrentSenderSelf(){return this.currentSender===this.selfPeer.id}close(){var e;(e=this.ws)==null||e.close(),this.ws=null}sendPing(){var e;(e=this.ws)==null||e.send(JSON.stringify(_()))}handleOnOpen(e){var t;this.connecting=!0;for(const[n,o]of this.beforeEnterRoomMethods)o(this.selfPeer.profile,this);this.doSendMessage(O({room:this.room,selfPeer:this.selfPeer}));for(let n of this.interimQueue)(t=this.ws)==null||t.send(JSON.stringify(n));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSender=t.sender,this.data(t)}data(e){if(e.type!="Pong")if(e.type==="EnterRoomAllowed"){const t=e;for(const[n,o]of this.enterRoomAllowedMethods)o(t,this);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const n of t.otherPeers)this.peers.set(n.id,n);if(this.dispatchCustomEvent("enterRoomAllowed",t),e.histories)for(const n of e.histories)this.data(n)}else if(e.type==="EnterRoomDenied"){const n=e;for(const[o,i]of this.enterRoomDeniedMethods)i(n,this);this.dispatchCustomEvent("enterRoomDenied",n)}else if(e.type=="LeaveRoomDone"){for(const[t,n]of this.leaveRoomDoneMethods)n(this);this.dispatchCustomEvent("leaveRoomDone")}else if(e.type==="UpdateRoomProfile"){const t=e;if(e.updates)for(const[n,o]of Object.entries(e.updates))this.room.profile[n]=o;if(e.deletes)for(const n of e.deletes)delete this.room.profile[n];for(const[n,o]of this.roomProfileUpdatedMethods)o(t,this);this.dispatchCustomEvent("roomProfileUpdated",t)}else if(e.type==="PeerEntered"){const t=e;this.peers.set(t.peer.id,t.peer);for(const[n,o]of this.peerEnteredMethods)o(t,this);this.dispatchCustomEvent("peerEntered",t)}else if(e.type==="PeerLeaved"){const t=e;this.peers.delete(e.peerId);for(const[n,o]of this.peerLeavedMethods)o(t,this);this.dispatchCustomEvent("peerLeaved",t)}else if(e.type==="UpdatePeerProfile"){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[o,i]of Object.entries(e.updates))t.profile[o]=i;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const n={...e,peerId:e.sender};for(const[o,i]of this.peerProfileUpdatedMethods)i(n,this);this.dispatchCustomEvent("peerProfileUpdated",n)}}else if(e.type==="InvokeFunction"){const t=`${e.funcId}`,n=this.sharedFunctions.get(t);if(n){const o=this.applyInvocation(n.original,e.args);o instanceof Promise&&o.then(()=>{var i;(i=n.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=n.reject)==null||i.apply(null,arguments)})}else console.warn("no suitable function for ",e)}else if(e.type==="UpdateObjectState"){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const n=this.sharedObjects.get(e.objId);n&&(n.revision=e.objRevision)}else if(e.type==="InvokeMethod"){if(e.objId!==void 0){const o=this.sharedObjects.get(e.objId);o!==void 0&&o.revision++}const t=`${e.objId}:${e.methodId}`,n=this.sharedMethods.get(t);if(n!=null&&n.original){const o=this.applyInvocation(n.original,e.args);o instanceof Promise&&o.then(()=>{var i;(i=n.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=n.reject)==null||i.apply(null,arguments)})}else console.warn("no suitable method for ",e)}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.warn("Unknown message type.",e)}isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,n="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:n,recipients:void 0,content:t})}unicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[n],content:t})}multicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:n,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}replacer(e,t){return t instanceof Map?Object.fromEntries(t):t}doSendMessage(e){var t;this.connecting?(t=this.ws)==null||t.send(JSON.stringify(e,this.replacer)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("share"in t){t.share.type||(t.share.type=M.type),t.share.maxLog||(t.share.maxLog=M.maxLog);const n=e.name,o=this.sharedFunctions.size,i=this.createFunctionProxy(e,t.share,o),a=function(){return i.apply(null,arguments)};return this.doSendMessage(C({definition:{funcId:o,name:n,config:t}})),a}return e}register(e,t=[]){if(!this.ws)return e;const n=e;if(n.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let o=n.constructor.name;n.__proto__.constructor.madoiClassConfig_&&(o=n.__proto__.constructor.madoiClassConfig_.className);const i=this.sharedObjects.size,a={instance:n,revision:0,modification:0};this.sharedObjects.set(i,a),n.madoiObjectId_=i;const h=new Array,y=new Array,g=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(m=>{const u=n[m];if(typeof u!="function"||!u.madoiMethodConfig_)return;const c=u.madoiMethodConfig_,l=h.length;g.set(m,l),h.push(u),y.push({methodId:l,name:m,config:c}),console.debug(`add config ${o}.${m}=${JSON.stringify(c)} from decorator`)});for(const m of t){const u=m.method,c=m,l=u.name;if("share"in c)c.share.type||(c.share.type=M.type),c.share.maxLog||(c.share.maxLog=M.maxLog);else if(!("hostOnly"in c)){if("getState"in c)c.getState.maxInterval||(c.getState.maxInterval=E.maxInterval);else if(!("setState"in c)){if(!("enterRoomAllowed"in c)){if(!("enterRoomDenied"in c)){if(!("leaveRoomDone"in c)){if(!("peerEntered"in c)){if(!("peerLeaved"in c))continue}}}}}}const P=g.get(l);if(typeof P>"u"){const A=h.length;g.set(l,A),h.push(u),y.push({methodId:A,name:m.method.name,config:c}),console.debug(`add config ${o}.${l}=${JSON.stringify(m)} from argument`)}else y[P].config=m,console.debug(`replace config ${o}.${l}=${JSON.stringify(m)} from argument`)}for(let m=0;m<h.length;m++){const u=h[m],c=y[m],l=c.config;if("share"in l){const P=this.createMethodProxy(u.bind(n),l.share,i,c.methodId);n[c.name]=function(){return a.modification++,P.apply(null,arguments)}}else if("hostOnly"in l){const P=this.addHostOnlyFunction(u.bind(n),l.hostOnly);n[c.name]=function(){return a.modification++,P.apply(null,arguments)}}else"getState"in l?this.getStateMethods.set(i,{method:u.bind(n),config:l.getState,lastGet:0}):"setState"in l?this.setStateMethods.set(i,u.bind(n)):"beforeEnterRoom"in l?this.beforeEnterRoomMethods.set(i,u.bind(n)):"enterRoomAllowed"in l?this.enterRoomAllowedMethods.set(i,u.bind(n)):"enterRoomDenied"in l?this.enterRoomDeniedMethods.set(i,u.bind(n)):"leaveRoomDone"in l?this.leaveRoomDoneMethods.set(i,u.bind(n)):"peerEntered"in l?this.peerEnteredMethods.set(i,u.bind(n)):"peerProfileUpdated"in l?this.peerProfileUpdatedMethods.set(i,u.bind(n)):"peerLeaved"in l&&this.peerLeavedMethods.set(i,u.bind(n))}const w=D({definition:{objId:i,className:o,methods:y}});return this.doSendMessage(w),e}createFunctionProxy(e,t,n){const o=`${n}`,i={original:e};this.sharedFunctions.set(o,i),i.promise=new Promise((h,y)=>{i.resolve=h,i.reject=y});const a=this;return function(){if(a.ws===null){if(e)return e.apply(null,arguments)}else{let h=null,y="BROADCAST";return t.type==="afterExec"&&(h=e.apply(null,arguments),y="OTHERCAST"),a.sendMessage(T(y,{funcId:n,args:Array.from(arguments)})),h??i.promise}}}createMethodProxy(e,t,n,o){const i=`${n}:${o}`,a={original:e};this.sharedMethods.set(i,a),a.promise=new Promise((y,g)=>{a.resolve=y,a.reject=g});const h=this;return function(){var y;if(h.ws===null){if(e)return e.apply(null,[...arguments,h])}else{let g=null,w="BROADCAST";return t.type==="afterExec"&&(g=e.apply(null,[...arguments,h]),w="OTHERCAST"),h.sendMessage(L(w,{objId:n,objRevision:(y=h.sharedObjects.get(n))==null?void 0:y.revision,methodId:o,args:Array.from(arguments)})),g??a.promise}}}addHostOnlyFunction(e,t){const n=this;return function(){let o=n.selfPeer.order;for(const i of n.peers.values())o>i.order&&(o=i.order);n.selfPeer.order===o&&e.apply(null,[...arguments,n])}}saveStates(){if(!(!this.ws||!this.connecting))for(let[e,t]of this.sharedObjects){if(t.modification==0)continue;const n=this.getStateMethods.get(e);if(!n)continue;const o=performance.now();(n.config.maxUpdates&&n.config.maxUpdates<=t.modification||n.config.maxInterval&&n.config.maxInterval<=o-n.lastGet)&&(this.doSendMessage(j({objId:e,objRevision:t.revision,state:n.method(this)})),n.lastGet=o,t.modification=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}d.BeforeEnterRoom=x,d.EnterRoomAllowed=B,d.EnterRoomDenied=J,d.GetState=F,d.HostOnly=H,d.LeaveRoomDone=G,d.Madoi=W,d.PeerEntered=z,d.PeerLeaved=q,d.PeerProfileUpdated=V,d.RoomProfileUpdated=Q,d.SetState=N,d.Share=k,d.ShareClass=$,d.TypedEventTarget=I,d.getStateConfigDefault=E,d.newDefineFunction=C,d.newDefineObject=D,d.newEnterRoom=O,d.newInvokeFunction=T,d.newInvokeMethod=L,d.newLeaveRoom=U,d.newPing=_,d.newUpdateObjectState=j,d.newUpdatePeerProfile=S,d.newUpdateRoomProfile=R,d.shareConfigDefault=M,Object.defineProperty(d,Symbol.toStringTag,{value:"Module"})});
