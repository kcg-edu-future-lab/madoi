(function(r,y){typeof exports=="object"&&typeof module<"u"?y(exports):typeof define=="function"&&define.amd?define(["exports"],y):(r=typeof globalThis<"u"?globalThis:r||self,y(r.madoi={}))})(this,function(r){"use strict";var Y=Object.defineProperty;var Z=(r,y,v)=>y in r?Y(r,y,{enumerable:!0,configurable:!0,writable:!0,value:v}):r[y]=v;var l=(r,y,v)=>Z(r,typeof y!="symbol"?y+"":y,v);class y extends EventTarget{dispatchCustomEvent(d,e){return super.dispatchEvent(new CustomEvent(d,{detail:e}))}}const v={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},E={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},O={sender:"__PEER__",recipients:void 0};function _(s=void 0){return{type:"Ping",...v,body:s}}function C(s){return{type:"EnterRoom",...v,...s}}function U(s){return{type:"LeaveRoom",...v,...s}}function w(s){return{type:"UpdateRoomProfile",...E,...s}}function R(s){return{type:"UpdatePeerProfile",...E,...s}}function j(s){return{type:"DefineFunction",...v,...s}}function D(s){return{type:"DefineObject",...v,...s}}function I(s,d){return{type:"InvokeFunction",castType:s,...O,...d}}function T(s){return{type:"UpdateObjectState",...v,...s}}function A(s,d){return{type:"InvokeMethod",castType:s,...O,...d}}function $(s={}){return d=>{d.madoiClassConfig_=s}}const P={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function F(s=P){const d=s;return d.type||(d.type="beforeExec"),d.maxLog||(d.maxLog=0),(e,t,n)=>{const o={share:d};e[t].madoiMethodConfig_=o}}const S={type:"beforeExec"};function k(s=S){const d={...s};return(e,t,n)=>{const o={notify:d};e[t].madoiMethodConfig_=o}}const b={maxInterval:5e3};function N(s=b){const d=s;return(e,t,n)=>{const o={getState:d};e[t].madoiMethodConfig_=o}}function x(s={}){const d=s;return(e,t,n)=>{const o={setState:d};e[t].madoiMethodConfig_=o}}function H(s={}){return(d,e,t)=>{const o={hostOnly:s};d[e].madoiMethodConfig_=o}}function B(s={}){const d=s;return(e,t,n)=>{const o={beforeEnterRoom:d};e[t].madoiMethodConfig_=o}}function J(s={}){const d=s;return(e,t,n)=>{const o={enterRoomAllowed:d};e[t].madoiMethodConfig_=o}}function G(s={}){const d=s;return(e,t,n)=>{const o={enterRoomDenied:d};e[t].madoiMethodConfig_=o}}function Q(s={}){const d=s;return(e,t,n)=>{const o={leaveRoomDone:d};e[t].madoiMethodConfig_=o}}function z(s={}){const d=s;return(e,t,n)=>{const o={roomProfileUpdated:d};e[t].madoiMethodConfig_=o}}function q(s={}){const d=s;return(e,t,n)=>{const o={peerEntered:d};e[t].madoiMethodConfig_=o}}function V(s={}){const d=s;return(e,t,n)=>{const o={peerLeaved:d};e[t].madoiMethodConfig_=o}}function W(s={}){const d=s;return(e,t,n)=>{const o={peerProfileUpdated:d};e[t].madoiMethodConfig_=o}}class K extends y{constructor(e,t,n,o){super();l(this,"connecting",!1);l(this,"interimQueue");l(this,"sharedFunctions",new Map);l(this,"sharedObjects",new Map);l(this,"sharedMethods",new Map);l(this,"getStateMethods",new Map);l(this,"setStateMethods",new Map);l(this,"beforeEnterRoomMethods",new Map);l(this,"enterRoomAllowedMethods",new Map);l(this,"enterRoomDeniedMethods",new Map);l(this,"leaveRoomDoneMethods",new Map);l(this,"roomProfileUpdatedMethods",new Map);l(this,"peerEnteredMethods",new Map);l(this,"peerLeavedMethods",new Map);l(this,"peerProfileUpdatedMethods",new Map);l(this,"url");l(this,"ws",null);l(this,"room",{id:"",spec:{maxLog:1e3},profile:{}});l(this,"selfPeer",{id:"",order:-1,profile:{}});l(this,"peers",new Map);l(this,"currentSender",null);l(this,"systemMessageTypes",["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"]);o&&(this.room={...this.room,...o}),n&&(this.selfPeer={...this.selfPeer,...n,order:-1}),this.interimQueue=new Array;const i=e.indexOf("?")!=-1?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${i}authToken=${t}`,this.room.id=e.split("rooms/")[1].split("?")[0];else{const c=document.querySelector("script[src$='madoi.js']").src.split("/",5),h=(c[0]=="http:"?"ws:":"wss:")+"//"+c[2]+"/"+c[3];this.url=`${h}/rooms/${e}${i}authToken=${t}`,this.room.id=e}this.ws=new WebSocket(this.url),this.ws.onopen=c=>this.handleOnOpen(c),this.ws.onclose=c=>this.handleOnClose(c),this.ws.onerror=c=>this.handleOnError(c),this.ws.onmessage=c=>this.handleOnMessage(c),setInterval(()=>{this.saveStates()},1e3),setInterval(()=>{this.sendPing()},3e4)}getRoomId(){return this.room.id}getRoomProfile(){var e;return(e=this.room)==null?void 0:e.profile}setRoomProfile(e,t){const n={};n[e]=t,this.sendMessage(w({updates:n}))}removeRoomProfile(e){this.sendMessage(w({deletes:[e]}))}getSelfPeerId(){var e;return(e=this.selfPeer)==null?void 0:e.id}getSelfPeerProfile(){return this.selfPeer.profile}updateSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const n={};n[e]=t,this.sendMessage(R({updates:n}))}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(R({deletes:[e]}))}getCurrentSender(){return this.currentSender?this.peers.get(this.currentSender):null}isCurrentSenderSelf(){return this.currentSender===this.selfPeer.id}close(){var e;(e=this.ws)==null||e.close(),this.ws=null}sendPing(){var e;(e=this.ws)==null||e.send(JSON.stringify(_()))}handleOnOpen(e){var t;this.connecting=!0;for(const[n,o]of this.beforeEnterRoomMethods)o(this.selfPeer.profile,this);this.doSendMessage(C({room:this.room,selfPeer:this.selfPeer}));for(let n of this.interimQueue)(t=this.ws)==null||t.send(JSON.stringify(n));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSender=t.sender,this.data(t)}data(e){if(e.type!="Pong")if(e.type==="EnterRoomAllowed"){const t=e;for(const[n,o]of this.enterRoomAllowedMethods)o(t,this);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const n of t.otherPeers)this.peers.set(n.id,n);if(this.dispatchCustomEvent("enterRoomAllowed",t),e.histories)for(const n of e.histories)this.data(n)}else if(e.type==="EnterRoomDenied"){const n=e;for(const[o,i]of this.enterRoomDeniedMethods)i(n,this);this.dispatchCustomEvent("enterRoomDenied",n)}else if(e.type=="LeaveRoomDone"){for(const[t,n]of this.leaveRoomDoneMethods)n(this);this.dispatchCustomEvent("leaveRoomDone")}else if(e.type==="UpdateRoomProfile"){const t=e;if(e.updates)for(const[n,o]of Object.entries(e.updates))this.room.profile[n]=o;if(e.deletes)for(const n of e.deletes)delete this.room.profile[n];for(const[n,o]of this.roomProfileUpdatedMethods)o(t,this);this.dispatchCustomEvent("roomProfileUpdated",t)}else if(e.type==="PeerEntered"){const t=e;this.peers.set(t.peer.id,t.peer);for(const[n,o]of this.peerEnteredMethods)o(t,this);this.dispatchCustomEvent("peerEntered",t)}else if(e.type==="PeerLeaved"){const t=e;this.peers.delete(e.peerId);for(const[n,o]of this.peerLeavedMethods)o(t,this);this.dispatchCustomEvent("peerLeaved",t)}else if(e.type==="UpdatePeerProfile"){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[o,i]of Object.entries(e.updates))t.profile[o]=i;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const n={...e,peerId:e.sender};for(const[o,i]of this.peerProfileUpdatedMethods)i(n,this);this.dispatchCustomEvent("peerProfileUpdated",n)}}else if(e.type==="InvokeFunction"){const t=`${e.funcId}`,n=this.sharedFunctions.get(t);if(n){const o=this.applyInvocation(n.original,e.args);o instanceof Promise&&o.then(()=>{var i;(i=n.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=n.reject)==null||i.apply(null,arguments)})}else console.warn("no suitable function for ",e)}else if(e.type==="UpdateObjectState"){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const n=this.sharedObjects.get(e.objId);n&&(n.revision=e.objRevision)}else if(e.type==="InvokeMethod"){if(e.objId!==void 0){const o=this.sharedObjects.get(e.objId);o!==void 0?(o.revision+1!==e.serverObjRevision&&console.error(`Found inconsistency. serverObjRevision must be ${o.revision+1} but ${e.serverObjRevision}.`,e),o.revision=e.serverObjRevision):console.error(`Found inconsistency. Object not found for id: ${e.objId}.`,e)}const t=`${e.objId}:${e.methodId}`,n=this.sharedMethods.get(t);if(n!=null&&n.original){const o=this.applyInvocation(n.original,e.args);o instanceof Promise&&o.then(()=>{var i;(i=n.resolve)==null||i.apply(null,arguments)}).catch(()=>{var i;(i=n.reject)==null||i.apply(null,arguments)})}else console.error("no suitable method for ",e)}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.warn("Unknown message type.",e)}isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,n="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:n,recipients:void 0,content:t})}unicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[n],content:t})}multicast(e,t,n){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:n,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}replacer(e,t){return t instanceof Map?Object.fromEntries(t):t}doSendMessage(e){var t;this.connecting?(t=this.ws)==null||t.send(JSON.stringify(e,this.replacer)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("share"in t){t.share.type||(t.share.type=P.type),t.share.maxLog||(t.share.maxLog=P.maxLog);const n=e.name,o=this.sharedFunctions.size,i=this.createFunctionProxy(e,t.share,o),c=function(){return i.apply(null,arguments)};return this.doSendMessage(j({definition:{funcId:o,name:n,config:t}})),c}return e}register(e,t=[]){if(!this.ws)return e;const n=e;if(n.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let o=n.constructor.name;n.__proto__.constructor.madoiClassConfig_&&(o=n.__proto__.constructor.madoiClassConfig_.className);const i=this.sharedObjects.size,c={instance:n,revision:0,modification:0};this.sharedObjects.set(i,c),n.madoiObjectId_=i;const h=new Array,p=new Array,g=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(m=>{const u=n[m];if(typeof u!="function"||!u.madoiMethodConfig_)return;const a=u.madoiMethodConfig_,f=h.length;g.set(m,f),h.push(u),p.push({methodId:f,name:m,config:a}),console.debug(`add config ${o}.${m}=${JSON.stringify(a)} from decorator`)});for(const m of t){const u=m.method,a=m,f=u.name;if("share"in a)a.share.type||(a.share.type=P.type),a.share.maxLog||(a.share.maxLog=P.maxLog);else if("notify"in a)a.notify.type||(a.notify.type=S.type);else if(!("hostOnly"in a)){if("getState"in a)a.getState.maxInterval||(a.getState.maxInterval=b.maxInterval);else if(!("setState"in a)){if(!("enterRoomAllowed"in a)){if(!("enterRoomDenied"in a)){if(!("leaveRoomDone"in a)){if(!("peerEntered"in a)){if(!("peerLeaved"in a))continue}}}}}}const M=g.get(f);if(typeof M>"u"){const L=h.length;g.set(f,L),h.push(u),p.push({methodId:L,name:m.method.name,config:a}),console.debug(`add config ${o}.${f}=${JSON.stringify(m)} from argument`)}else p[M].config=m,console.debug(`replace config ${o}.${f}=${JSON.stringify(m)} from argument`)}for(let m=0;m<h.length;m++){const u=h[m],a=p[m],f=a.config;if("share"in f){const M=this.createMethodProxy(u.bind(n),f.share,i,a.methodId);n[a.name]=function(){return c.modification++,M.apply(null,arguments)}}else if("notify"in f){const M=this.createMethodProxy(u.bind(n),f.notify,i,a.methodId);n[a.name]=function(){return M.apply(null,arguments)}}else if("hostOnly"in f){const M=this.addHostOnlyFunction(u.bind(n),f.hostOnly);n[a.name]=function(){return c.modification++,M.apply(null,arguments)}}else"getState"in f?this.getStateMethods.set(i,{method:u.bind(n),config:f.getState,lastGet:0}):"setState"in f?this.setStateMethods.set(i,u.bind(n)):"beforeEnterRoom"in f?this.beforeEnterRoomMethods.set(i,u.bind(n)):"enterRoomAllowed"in f?this.enterRoomAllowedMethods.set(i,u.bind(n)):"enterRoomDenied"in f?this.enterRoomDeniedMethods.set(i,u.bind(n)):"leaveRoomDone"in f?this.leaveRoomDoneMethods.set(i,u.bind(n)):"peerEntered"in f?this.peerEnteredMethods.set(i,u.bind(n)):"peerProfileUpdated"in f?this.peerProfileUpdatedMethods.set(i,u.bind(n)):"peerLeaved"in f&&this.peerLeavedMethods.set(i,u.bind(n))}const X=D({definition:{objId:i,className:o,methods:p}});return this.doSendMessage(X),e}createFunctionProxy(e,t,n){const o=`${n}`,i={original:e};this.sharedFunctions.set(o,i),i.promise=new Promise((h,p)=>{i.resolve=h,i.reject=p});const c=this;return function(){if(c.ws===null){if(e)return e.apply(null,arguments)}else{let h=null,p="BROADCAST";return t.type==="afterExec"&&(h=e.apply(null,arguments),p="OTHERCAST"),c.sendMessage(I(p,{funcId:n,args:Array.from(arguments)})),h??i.promise}}}createMethodProxy(e,t,n,o){const i=`${n}:${o}`,c={original:e};this.sharedMethods.set(i,c),c.promise=new Promise((p,g)=>{c.resolve=p,c.reject=g});const h=this;return function(){if(h.ws===null){if(e)return e.apply(null,[...arguments,h])}else{let p=null,g="BROADCAST";return t.type==="afterExec"&&(p=e.apply(null,[...arguments,h]),g="OTHERCAST"),h.sendMessage(A(g,{objId:n,objRevision:h.sharedObjects.get(n).revision,methodId:o,args:Array.from(arguments)})),p??c.promise}}}addHostOnlyFunction(e,t){const n=this;return function(){let o=n.selfPeer.order;for(const i of n.peers.values())o>i.order&&(o=i.order);n.selfPeer.order===o&&e.apply(null,[...arguments,n])}}saveStates(){if(!(!this.ws||!this.connecting))for(let[e,t]of this.sharedObjects){if(t.modification==0)continue;const n=this.getStateMethods.get(e);if(!n)continue;const o=performance.now();(n.config.maxUpdates&&n.config.maxUpdates<=t.modification||n.config.maxInterval&&n.config.maxInterval<=o-n.lastGet)&&(this.doSendMessage(T({objId:e,objRevision:t.revision,state:n.method(this)})),n.lastGet=o,t.modification=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}r.BeforeEnterRoom=B,r.EnterRoomAllowed=J,r.EnterRoomDenied=G,r.GetState=N,r.HostOnly=H,r.LeaveRoomDone=Q,r.Madoi=K,r.Notify=k,r.PeerEntered=q,r.PeerLeaved=V,r.PeerProfileUpdated=W,r.RoomProfileUpdated=z,r.SetState=x,r.Share=F,r.ShareClass=$,r.getStateConfigDefault=b,r.newDefineFunction=j,r.newDefineObject=D,r.newEnterRoom=C,r.newInvokeFunction=I,r.newInvokeMethod=A,r.newLeaveRoom=U,r.newPing=_,r.newUpdateObjectState=T,r.newUpdatePeerProfile=R,r.newUpdateRoomProfile=w,r.notifyConfigDefault=S,r.shareConfigDefault=P,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
