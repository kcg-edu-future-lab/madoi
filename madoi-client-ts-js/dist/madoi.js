!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.madoi=t():e.madoi=t()}(self,(()=>(()=>{"use strict";var e={d:(t,o)=>{for(var n in o)e.o(o,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:o[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{EnterRoomAllowed:()=>R,EnterRoomDenied:()=>O,GetState:()=>w,HostOnly:()=>b,LeaveRoomDone:()=>E,Madoi:()=>T,PeerEntered:()=>j,PeerLeaved:()=>_,PeerProfileUpdated:()=>C,RoomProfileUpdated:()=>I,SetState:()=>S,Share:()=>v,ShareClass:()=>y,TypedEventTarget:()=>m,getStateConfigDefault:()=>P,newDefineFunction:()=>c,newDefineObject:()=>f,newEnterRoom:()=>i,newInvokeFunction:()=>h,newInvokeMethod:()=>u,newLeaveRoom:()=>d,newPing:()=>r,newUpdateObjectState:()=>p,newUpdatePeerProfile:()=>l,newUpdateRoomProfile:()=>a,shareConfigDefault:()=>M});const o={sender:"__PEER__",castType:"PEERTOSERVER",recipients:void 0},n={sender:"__PEER__",castType:"BROADCAST",recipients:void 0},s={sender:"__PEER__",recipients:void 0};function r(e=void 0){return{type:"Ping",...o,body:e}}function i(e){return{type:"EnterRoom",...o,...e}}function d(e){return{type:"LeaveRoom",...o,...e}}function a(e){return{type:"UpdateRoomProfile",...n,...e}}function l(e){return{type:"UpdatePeerProfile",...n,...e}}function c(e){return{type:"DefineFunction",...o,...e}}function f(e){return{type:"DefineObject",...o,...e}}function h(e,t){return{type:"InvokeFunction",castType:e,...s,...t}}function p(e){return{type:"UpdateObjectState",...o,...e}}function u(e,t){return{type:"InvokeMethod",castType:e,...s,...t}}class m extends EventTarget{}class g extends m{fire(e,t){super.dispatchEvent(new CustomEvent(e,{detail:t}))}}function y(e={}){return t=>{t.madoiClassConfig_=e}}const M={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function v(e=M){const t=e;return t.type||(t.type="beforeExec"),t.maxLog||(t.maxLog=0),(e,o,n)=>{const s={share:t};e[o].madoiMethodConfig_=s}}const P={maxInterval:5e3};function w(e=P){const t=e;return(e,o,n)=>{const s={getState:t};e[o].madoiMethodConfig_=s}}function S(e={}){const t=e;return(e,o,n)=>{const s={setState:t};e[o].madoiMethodConfig_=s}}function b(e={}){return(t,o,n)=>{const s={hostOnly:e};t[o].madoiMethodConfig_=s}}function R(e={}){const t=e;return(e,o,n)=>{const s={enterRoomAllowed:t};e[o].madoiMethodConfig_=s}}function O(e={}){const t=e;return(e,o,n)=>{const s={enterRoomDenied:t};e[o].madoiMethodConfig_=s}}function E(e={}){const t=e;return(e,o,n)=>{const s={leaveRoomDone:t};e[o].madoiMethodConfig_=s}}function I(e={}){const t=e;return(e,o,n)=>{const s={roomProfileUpdated:t};e[o].madoiMethodConfig_=s}}function j(e={}){const t=e;return(e,o,n)=>{const s={peerEntered:t};e[o].madoiMethodConfig_=s}}function _(e={}){const t=e;return(e,o,n)=>{const s={peerLeaved:t};e[o].madoiMethodConfig_=s}}function C(e={}){const t=e;return(e,o,n)=>{const s={peerProfileUpdated:t};e[o].madoiMethodConfig_=s}}class T extends g{connecting=!1;interimQueue;sharedFunctions=new Map;sharedObjects=new Map;sharedMethods=new Map;getStateMethods=new Map;setStateMethods=new Map;enterRoomAllowedMethods=new Map;enterRoomDeniedMethods=new Map;leaveRoomDoneMethods=new Map;roomProfileUpdatedMethods=new Map;peerEnteredMethods=new Map;peerLeavedMethods=new Map;peerProfileUpdatedMethods=new Map;url;ws=null;room={id:"",spec:{maxLog:1e3},profile:{}};selfPeer;peers=new Map;currentSender=null;constructor(e,t,o,n){super(),this.selfPeer=o?{...o,order:-1}:{id:"",order:-1,profile:{}},this.interimQueue=new Array,this.doSendMessage(i({room:n,selfPeer:this.selfPeer}));const s=-1!=e.indexOf("?")?"&":"?";if(e.match(/^wss?:\/\//))this.url=`${e}${s}authToken=${t}`;else{const o=document.querySelector("script[src$='madoi.js']").src.split("/",5),n=("http:"==o[0]?"ws:":"wss:")+"//"+o[2]+"/"+o[3];this.url=`${n}/rooms/${e}${s}authToken=${t}`}this.ws=new WebSocket(this.url),this.ws.onopen=e=>this.handleOnOpen(e),this.ws.onclose=e=>this.handleOnClose(e),this.ws.onerror=e=>this.handleOnError(e),this.ws.onmessage=e=>this.handleOnMessage(e),setInterval((()=>{this.saveStates()}),1e3),setInterval((()=>{this.sendPing()}),3e4)}getRoomProfile(){return this.room?.profile}setRoomProfile(e,t){const o={};o[e]=t,this.sendMessage(a({updates:o}))}removeRoomProfile(e){this.sendMessage(a({deletes:[e]}))}getSelfPeerId(){return this.selfPeer?.id}getSelfPeerProfile(){return this.selfPeer.profile}setSelfPeerProfile(e,t){this.selfPeer.profile[e]=t;const o={};o[e]=t,this.sendMessage(l({updates:o}))}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(l({deletes:[e]}))}getCurrentSender(){return this.currentSender?this.peers.get(this.currentSender):null}isCurrentSenderSelf(){return this.currentSender===this.selfPeer.id}close(){this.ws?.close(),this.ws=null}sendPing(){this.ws?.send(JSON.stringify(r()))}handleOnOpen(e){this.connecting=!0;for(let e of this.interimQueue)this.ws?.send(JSON.stringify(e));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSender=t.sender,this.data(t)}data(e){if("Pong"==e.type);else if("EnterRoomAllowed"===e.type){const t=e;for(const[e,o]of this.enterRoomAllowedMethods)o(t);this.room=e.room,this.selfPeer.order=e.selfPeer.order,this.peers.set(t.selfPeer.id,{...t.selfPeer,profile:this.selfPeer.profile});for(const e of t.otherPeers)this.peers.set(e.id,e);if(this.fire("enterRoomAllowed",t),e.histories)for(const t of e.histories)this.data(t)}else if("EnterRoomDenied"===e.type){const t=e;for(const[e,o]of this.enterRoomDeniedMethods)o(t);this.fire("enterRoomDenied",t)}else if("LeaveRoomDone"==e.type){for(const[e,t]of this.leaveRoomDoneMethods)t();this.fire("leaveRoomDone",{})}else if("UpdateRoomProfile"===e.type){const t=e;if(e.updates)for(const[t,o]of Object.entries(e.updates))this.room.profile[t]=o;if(e.deletes)for(const t of e.deletes)delete this.room.profile[t];for(const[e,o]of this.roomProfileUpdatedMethods)o(t);this.fire("roomProfileUpdated",t)}else if("PeerEntered"===e.type){const t=e;this.peers.set(t.peer.id,t.peer);for(const[e,o]of this.peerEnteredMethods)o(t);this.fire("peerEntered",{peer:t.peer})}else if("PeerLeaved"===e.type){this.peers.delete(e.peerId);for(const[t,o]of this.peerLeavedMethods)o(e.peerId);this.fire("peerLeaved",{peerId:e.peerId})}else if("UpdatePeerProfile"===e.type){const t=this.peers.get(e.sender);if(e.sender&&t){if(e.updates)for(const[o,n]of Object.entries(e.updates))t.profile[o]=n;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const o={...e,peerId:e.peerId};for(const[e,t]of this.peerProfileUpdatedMethods)t(o);this.fire("peerProfileUpdated",o)}}else if("InvokeFunction"===e.type){const t=`${e.funcId}`,o=this.sharedFunctions.get(t);if(o){const t=this.applyInvocation(o.original,e.args);t instanceof Promise&&t.then((()=>{o.resolve?.apply(null,arguments)})).catch((()=>{o.reject?.apply(null,arguments)}))}else console.warn("no suitable function for ",e)}else if("UpdateObjectState"===e.type){const t=this.setStateMethods.get(e.objId);t&&t(e.state,e.objRevision);const o=this.sharedObjects.get(e.objId);o&&(o.revision=e.objRevision)}else if("InvokeMethod"===e.type){if(void 0!==e.objId){const t=this.sharedObjects.get(e.objId);void 0!==t&&t.revision++}const t=`${e.objId}:${e.methodId}`,o=this.sharedMethods.get(t);if(o?.original){const t=this.applyInvocation(o.original,e.args);t instanceof Promise&&t.then((()=>{o.resolve?.apply(null,arguments)})).catch((()=>{o.reject?.apply(null,arguments)}))}else console.warn("no suitable method for ",e)}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.warn("Unknown message type.",e)}systemMessageTypes=["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineFunction","DefineObject","InvokeFunction","UpdateObjectState","InvokeMethod"];isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,o="BROADCAST"){this.ws&&this.sendMessage({type:e,sender:this.selfPeer.id,castType:o,recipients:void 0,content:t})}unicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"UNICAST",recipients:[o],content:t})}multicast(e,t,o){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"MULTICAST",recipients:o,content:t})}broadcast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"BROADCAST",recipients:void 0,content:t})}othercast(e,t){this.sendMessage({type:e,sender:this.selfPeer.id,castType:"OTHERCAST",recipients:void 0,content:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}doSendMessage(e){this.connecting?this.ws?.send(JSON.stringify(e)):this.interimQueue.push(e)}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("share"in t){t.share.type||(t.share.type=M.type),t.share.maxLog||(t.share.maxLog=M.maxLog);const o=e.name,n=this.sharedFunctions.size,s=this.createFunctionProxy(e,t.share,n),r=function(){return s.apply(null,arguments)};return this.doSendMessage(c({definition:{funcId:n,name:o,config:t}})),r}return e}register(e,t=[]){if(!this.ws)return e;const o=e;if(o.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let n=o.constructor.name;o.__proto__.constructor.madoiClassConfig_&&(n=o.__proto__.constructor.madoiClassConfig_.className);const s=this.sharedObjects.size,r={instance:o,revision:0,modification:0};this.sharedObjects.set(s,r),o.madoiObjectId_=s;const i=new Array,d=new Array,a=new Map;Object.getOwnPropertyNames(Object.getPrototypeOf(o)).forEach((e=>{const t=o[e];if("function"!=typeof t)return;if(!t.madoiMethodConfig_)return;const s=t.madoiMethodConfig_,r=i.length;a.set(e,r),i.push(t),d.push({methodId:r,name:e,config:s}),console.debug(`add config ${n}.${e}=${JSON.stringify(s)} from decorator`)}));for(const e of t){const t=e.method,o=e,s=t.name;if("share"in o)o.share.type||(o.share.type=M.type),o.share.maxLog||(o.share.maxLog=M.maxLog);else if("hostOnly"in o);else if("getState"in o)o.getState.maxInterval||(o.getState.maxInterval=P.maxInterval);else if("setState"in o);else if("enterRoomAllowed"in o);else if("enterRoomDenied"in o);else if("leaveRoomDone"in o);else if("peerEntered"in o);else if(!("peerLeaved"in o))continue;const r=a.get(s);if(void 0===r){const r=i.length;a.set(s,r),i.push(t),d.push({methodId:r,name:e.method.name,config:o}),console.debug(`add config ${n}.${s}=${JSON.stringify(e)} from argument`)}else d[r].config=e,console.debug(`replace config ${n}.${s}=${JSON.stringify(e)} from argument`)}for(let e=0;e<i.length;e++){const t=i[e],n=d[e],a=n.config;if("share"in a){const e=this.createMethodProxy(t.bind(o),a.share,s,n.methodId);o[n.name]=function(){return r.modification++,e.apply(null,arguments)}}else if("hostOnly"in a){const e=this.addHostOnlyFunction(t.bind(o),a.hostOnly);o[n.name]=function(){return e.apply(null,arguments)}}else"getState"in a?this.getStateMethods.set(s,{method:t.bind(o),config:a.getState,lastGet:0}):"setState"in a?this.setStateMethods.set(s,t.bind(o)):"enterRoomAllowed"in a?this.enterRoomAllowedMethods.set(s,t.bind(o)):"enterRoomDenied"in a?this.enterRoomDeniedMethods.set(s,t.bind(o)):"leaveRoomDone"in a?this.leaveRoomDoneMethods.set(s,t.bind(o)):"peerEntered"in a?this.peerEnteredMethods.set(s,t.bind(o)):"peerProfileUpdated"in a?this.peerProfileUpdatedMethods.set(s,t.bind(o)):"peerLeaved"in a&&this.peerLeavedMethods.set(s,t.bind(o))}const l=f({definition:{objId:s,className:n,methods:d}});return this.doSendMessage(l),e}createFunctionProxy(e,t,o){const n=`${o}`,s={original:e};this.sharedFunctions.set(n,s),s.promise=new Promise(((e,t)=>{s.resolve=e,s.reject=t}));const r=this;return function(){if(null!==r.ws){let n=null,i="BROADCAST";return"afterExec"===t.type&&(n=e.apply(null,arguments),i="OTHERCAST"),r.sendMessage(h(i,{funcId:o,args:Array.from(arguments)})),null!=n?n:s.promise}if(e)return e.apply(null,arguments)}}createMethodProxy(e,t,o,n){const s=`${o}:${n}`,r={original:e};this.sharedMethods.set(s,r),r.promise=new Promise(((e,t)=>{r.resolve=e,r.reject=t}));const i=this;return function(){if(null!==i.ws){let s=null,d="BROADCAST";return"afterExec"===t.type&&(s=e.apply(null,arguments),d="OTHERCAST"),i.sendMessage(u(d,{objId:o,objRevision:i.sharedObjects.get(o)?.revision,methodId:n,args:Array.from(arguments)})),null!=s?s:r.promise}if(e)return e.apply(null,arguments)}}addHostOnlyFunction(e,t){const o=this;return function(){let t=o.selfPeer.order;for(const e of o.peers.values())t>e.order&&(t=e.order);o.selfPeer.order===t&&e.apply(null,arguments)}}saveStates(){if(this.ws&&this.connecting)for(let[e,t]of this.sharedObjects){if(0==t.modification)continue;const o=this.getStateMethods.get(e);if(!o)continue;const n=performance.now();(o.config.maxUpdates&&o.config.maxUpdates<=t.modification||o.config.maxInterval&&o.config.maxInterval<=n-o.lastGet)&&(this.doSendMessage(p({objId:e,objRevision:t.revision,state:o.method()})),o.lastGet=n,t.modification=0,console.debug(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}return t})()));