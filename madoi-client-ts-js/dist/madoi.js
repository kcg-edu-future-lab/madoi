!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.madoi=t():e.madoi=t()}(self,(()=>(()=>{"use strict";var e={d:(t,o)=>{for(var s in o)e.o(o,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:o[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{EnterRoomAllowed:()=>f,EnterRoomDenied:()=>h,GetState:()=>a,HostOnly:()=>l,LeaveRoomDone:()=>p,Madoi:()=>D,PeerEntered:()=>m,PeerLeaved:()=>g,PeerProfileUpdated:()=>y,RoomProfileUpdated:()=>u,SetState:()=>c,Share:()=>r,ShareClass:()=>n,getStateConfigDefault:()=>d,newDefineFunction:()=>I,newDefineObject:()=>O,newEnterRoom:()=>b,newInvokeFunction:()=>E,newInvokeMethod:()=>j,newLeaveRoom:()=>S,newPing:()=>P,newUpdateObjectState:()=>C,newUpdatePeerProfile:()=>R,newUpdateRoomProfile:()=>w,shareConfigDefault:()=>i});class o extends EventTarget{}class s extends o{fire(e,t){super.dispatchEvent(new CustomEvent(e,{detail:t}))}}function n(e={}){return t=>{t.madoiClassConfig_=e}}const i={type:"beforeExec",maxLog:0,allowedTo:["USER"]};function r(e=i){const t=e;return t.type||(t.type="beforeExec"),t.maxLog||(t.maxLog=0),(e,o,s)=>{const n={share:t};e[o].madoiMethodConfig_=n}}const d={maxInterval:5e3};function a(e=d){const t=e;return(e,o,s)=>{const n={getState:t};e[o].madoiMethodConfig_=n}}function c(e={}){const t=e;return(e,o,s)=>{const n={setState:t};e[o].madoiMethodConfig_=n}}function l(e={}){return(t,o,s)=>{const n={hostOnly:e};t[o].madoiMethodConfig_=n}}function f(e={}){const t=e;return(e,o,s)=>{const n={enterRoomAllowed:t};e[o].madoiMethodConfig_=n}}function h(e={}){const t=e;return(e,o,s)=>{const n={enterRoomDenied:t};e[o].madoiMethodConfig_=n}}function p(e={}){const t=e;return(e,o,s)=>{const n={leaveRoomDone:t};e[o].madoiMethodConfig_=n}}function u(e={}){const t=e;return(e,o,s)=>{const n={roomProfileUpdated:t};e[o].madoiMethodConfig_=n}}function m(e={}){const t=e;return(e,o,s)=>{const n={peerEntered:t};e[o].madoiMethodConfig_=n}}function g(e={}){const t=e;return(e,o,s)=>{const n={peerLeaved:t};e[o].madoiMethodConfig_=n}}function y(e={}){const t=e;return(e,o,s)=>{const n={peerProfileUpdated:t};e[o].madoiMethodConfig_=n}}const M={castType:"PEERTOSERVER",recipients:void 0},v={castType:"BROADCAST",recipients:void 0};function P(e=void 0){return{type:"Ping",...M,body:e}}function b(e){return{type:"EnterRoom",...M,...e}}function S(e){return{type:"LeaveRoom",...M,...e}}function w(e){return{type:"UpdateRoomProfile",...v,...e}}function R(e){return{type:"UpdatePeerProfile",...v,...e}}function O(e){return{type:"DefineObject",...M,...e}}function I(e){return{type:"DefineFunction",...M,...e}}function j(e,t){return{type:"InvokeMethod",castType:e,recipients:void 0,...t}}function E(e,t){return{type:"InvokeFunction",castType:e,recipients:void 0,...t}}function C(e){return{type:"UpdateObjectState",...v,...e}}class D extends s{connecting=!1;interimQueue;sharedFunctions=[];sharedObjects=[];getStateMethods=new Map;setStateMethods=new Map;enterRoomAllowedMethods=new Map;enterRoomDeniedMethods=new Map;leaveRoomDoneMethods=new Map;roomProfileUpdatedMethods=new Map;peerEnteredMethods=new Map;peerLeavedMethods=new Map;peerProfileUpdatedMethods=new Map;promises={};objectModifications=new Map;objectRevisions=new Map;url;ws=null;room;selfPeer;peers=new Map;currentSender=null;constructor(e,t,o){if(super(),this.selfPeer=t?{...t,order:-1}:{id:"",order:-1,profile:{}},this.interimQueue=new Array,this.doSendMessage(b({roomProfile:o,selfPeer:{id:"",profile:{},...t,order:-1}})),e.match(/^wss?:\/\//))this.url=`${e}`;else{const t=document.querySelector("script[src$='madoi.js']").src.split("/",5),o=("http:"==t[0]?"ws:":"wss:")+"//"+t[2]+"/"+t[3];this.url=`${o}/rooms/${e}`}this.ws=new WebSocket(this.url),this.ws.onopen=e=>this.handleOnOpen(e),this.ws.onclose=e=>this.handleOnClose(e),this.ws.onerror=e=>this.handleOnError(e),this.ws.onmessage=e=>this.handleOnMessage(e),setInterval((()=>{this.saveStates()}),1e3),setInterval((()=>{this.sendPing()}),3e4)}getRoomProfile(){return this.room?.profile}setRoomProfile(e,t){this.sendMessage(w({updates:{name:t}}))}removeRoomProfile(e){this.sendMessage(w({deletes:[e]}))}getSelfPeerId(){return this.selfPeer?.id}getSelfPeerProfile(){return this.selfPeer.profile}setSelfPeerProfile(e,t){this.selfPeer.profile[e]=t,this.sendMessage(R({updates:{name:t}}))}removeSelfPeerProfile(e){delete this.selfPeer.profile[e],this.sendMessage(R({deletes:[e]}))}getCurrentSender(){return this.currentSender?this.peers.get(this.currentSender):null}isCurrentSenderSelf(){return this.currentSender===this.selfPeer.id}close(){this.ws?.close()}sendPing(){this.ws?.send(JSON.stringify(P()))}handleOnOpen(e){this.connecting=!0;for(let e of this.interimQueue)this.ws?.send(JSON.stringify(e));this.interimQueue=[]}handleOnClose(e){console.debug(`websocket closed because: ${e.reason}.`),this.connecting=!1,this.ws=null}handleOnError(e){}handleOnMessage(e){const t=JSON.parse(e.data);this.currentSender=t.sender,this.data(t)}data(e){if("Pong"==e.type);else if("EnterRoomAllowed"===e.type){for(const[t,o]of this.enterRoomAllowedMethods)o(e.selfPeer,e.otherPeers,e.histories);this.selfPeer.id=e.selfPeer.id,this.selfPeer.order=e.selfPeer.order,this.peers.set(e.selfPeer.id,{...e.selfPeer,profile:this.selfPeer.profile});for(const t of e.otherPeers)this.peers.set(t.id,t);if(this.fire("enterRoomAllowed",{room:e.room,selfPeer:e.selfPeer,otherPeers:e.otherPeers}),e.histories)for(const t of e.histories)this.data(t)}else if("EnterRoomDenied"==e.type){for(const[e,t]of this.enterRoomDeniedMethods)t();this.fire("enterRoomDenied",{})}else if("LeaveRoomDone"==e.type){for(const[e,t]of this.leaveRoomDoneMethods)t();this.fire("leaveRoomDone",{})}else if("UpdateRoomProfile"==e.type){const t=this.room;if(e.peerId&&t){if(e.updates)for(const[o,s]of Object.entries(e.updates))t.profile[o]=s;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const o={...e,roomId:e.roomId};for(const[e,t]of this.roomProfileUpdatedMethods)t(o);this.fire("roomProfileUpdated",o)}}else if("PeerEntered"==e.type){this.peers.set(e.peer.id,e.peer);for(const[t,o]of this.peerEnteredMethods)o(e.peer);this.fire("peerEntered",e.peer)}else if("PeerLeaved"==e.type){this.peers.delete(e.peerId);for(const[t,o]of this.peerLeavedMethods)o(e.peerId);this.fire("peerLeaved",e.peerId)}else if("UpdatePeerProfile"==e.type){const t=this.peers.get(e.peerId);if(e.peerId&&t){if(e.updates)for(const[o,s]of Object.entries(e.updates))t.profile[o]=s;if(e.deletes)for(const o of e.deletes)delete t.profile[o];const o={...e,peerId:e.peerId};for(const[e,t]of this.peerProfileUpdatedMethods)t(o);this.fire("peerProfileUpdated",o)}}else if("InvokeMethod"==e.type){if(e.objId){const t=this.objectRevisions.get(e.objId);this.objectRevisions.set(e.objId,(t||0)+1)}const t=this.sharedFunctions[e.methodId];if(t){const o=this.applyInvocation(t,e.args);o instanceof Promise&&o.then((()=>{this.promises[e.methodId].resolve.apply(null,arguments)})).catch((()=>{this.promises[e.methodId].reject.apply(null,arguments)}))}else console.warn("no suitable method for ",e)}else if("InvokeFunction"==e.type){const t=this.sharedFunctions[e.funcId];if(t){const o=this.applyInvocation(t,e.args);o instanceof Promise&&o.then((()=>{this.promises[e.methodId].resolve.apply(null,arguments)})).catch((()=>{this.promises[e.methodId].reject.apply(null,arguments)}))}else console.warn("no suitable function for ",e)}else if("UpdateObjectState"==e.type){const t=this.setStateMethods.get(e.objId);t&&t(JSON.parse(e.state),e.revision),this.objectRevisions.set(e.objId,e.revision)}else e.type?this.dispatchEvent(new CustomEvent(e.type,{detail:e})):console.log("Unknown message type.",e)}systemMessageTypes=["Ping","Pong","EnterRoom","EnterRoomAllowed","EnterRoomDenied","LeaveRoom","LeaveRoomDone","UpdateRoomProfile","PeerArrived","PeerLeaved","UpdatePeerProfile","DefineObject","DefineFunction","InvokeMethod","InvokeFunction","UpdateObjectState"];isSystemMessageType(e){return e in this.systemMessageTypes}send(e,t,o="BROADCAST"){this.ws&&this.sendMessage({type:e,castType:o,body:t})}unicast(e,t,o){this.sendMessage({type:e,castType:"UNICAST",recipients:[o],body:t})}multicast(e,t,o){this.sendMessage({type:e,castType:"MULTICAST",recipients:o,body:t})}broadcast(e,t){this.sendMessage({type:e,castType:"BROADCAST",body:t})}othercast(e,t){this.sendMessage({type:e,castType:"OTHERCAST",body:t})}sendMessage(e){if(this.isSystemMessageType(e.type))throw new Error("システムメッセージは送信できません。");this.doSendMessage(e)}addReceiver(e,t){if(this.isSystemMessageType(e))throw new Error("システムメッセージのレシーバは登録できません。");this.addEventListener(e,t)}removeReceiver(e,t){this.removeEventListener(e,t)}doSendMessage(e){this.connecting?this.ws?.send(JSON.stringify(e)):this.interimQueue.push(e)}register(e,t=[]){if(!this.ws)return e;const o=e;if(o.madoiObjectId_)return console.warn("Ignore object registration because it's already registered."),e;let s=o.constructor.name;o.__proto__.constructor.madoiClassConfig_&&(s=o.__proto__.constructor.madoiClassConfig_.className);const n=this.sharedObjects.length;this.sharedObjects.push(o),o.madoiObjectId_=n;const r=new Array,a=new Array,c=new Map;Object.getOwnPropertyNames(o.__proto__).forEach((e=>{const t=o[e];if("function"!=typeof t)return;if(!t.madoiMethodConfig_)return;const n=t.madoiMethodConfig_,i=r.length;c.set(e,i),r.push(t),a.push({methodId:i,name:e,config:n}),console.debug(`add config ${s}.${e}=${JSON.stringify(n)} from decorator`)}));for(const e of t){const t=e.method,o=e,n=t.name;if("share"in o)o.share.type||(o.share.type=i.type),o.share.maxLog||(o.share.maxLog=i.maxLog);else if("hostOnly"in o);else if("getState"in o)o.getState.maxInterval||(o.getState.maxInterval=d.maxInterval);else if("setState"in o);else if("enterRoomAllowed"in o);else if("enterRoomDenied"in o);else if("leaveRoomDone"in o);else if("peerEntered"in o);else if(!("peerLeaved"in o))continue;const l=c.get(n);if(void 0===l){const i=r.length;c.set(n,i),r.push(t),a.push({methodId:i,name:e.method.name,config:o}),console.debug(`add config ${s}.${n}=${JSON.stringify(e)} from argument`)}else a[l].config=e,console.debug(`replace config ${s}.${n}=${JSON.stringify(e)} from argument`)}for(let e=0;e<r.length;e++){const t=r[e],s=a[e],i=s.config;if("share"in i){const[e,r]=this.addSharedFunction(t.bind(o),i.share,n);s.methodId=e,this.objectModifications.set(n,0),this.objectRevisions.set(n,0);const d=this;o[t.name]=function(){const e=d.objectModifications.get(n);d.objectModifications.set(n,e+1);const t=d.objectRevisions.get(n);return d.objectRevisions.set(n,t+1),r.apply(null,arguments)}}else if("hostOnly"in i){const e=this.addHostOnlyFunction(t.bind(o),i.hostOnly);o[t.name]=function(){return e.apply(null,arguments)}}else"getState"in i?this.getStateMethods.set(n,{method:t.bind(o),config:i.getState,lastGet:0}):"setState"in i?this.setStateMethods.set(n,t.bind(o)):"enterRoomAllowed"in i?this.enterRoomAllowedMethods.set(n,t.bind(o)):"enterRoomDenied"in i?this.enterRoomDeniedMethods.set(n,t.bind(o)):"leaveRoomDone"in i?this.leaveRoomDoneMethods.set(n,t.bind(o)):"peerEntered"in i?this.peerEnteredMethods.set(n,t.bind(o)):"peerProfileUpdated"in i?this.peerProfileUpdatedMethods.set(n,t.bind(o)):"peerLeaved"in i&&this.peerLeavedMethods.set(n,t.bind(o))}const l=O({definition:{objId:n,className:s,methods:a}});return this.doSendMessage(l),e}registerFunction(e,t={share:{}}){if("hostOnly"in t)return this.addHostOnlyFunction(e,t);if("share"in t){t.share.type||(t.share.type=i.type),t.share.maxLog||(t.share.maxLog=i.maxLog);const o=e.name,[s,n]=this.addSharedFunction(e,t.share),r=function(){return n.apply(null,arguments)};return this.doSendMessage(I({definition:{funcId:s,name:o,config:t}})),r}return e}addSharedFunction(e,t,o){const s=this.sharedFunctions.length;this.sharedFunctions.push(e),this.promises[s]={},this.promises[s].promise=new Promise(((e,t)=>{this.promises[s].resolve=e,this.promises[s].reject=t}));const n=this;return[s,function(){if(null!=n.ws){let i=null,r="BROADCAST";return"afterExec"===t.type&&(i=e.apply(null,arguments),r="OTHERCAST"),void 0!==o?n.sendMessage(j(r,{objId:o,methodId:s,args:Array.from(arguments)})):n.sendMessage(E(r,{funcId:s,args:Array.from(arguments)})),null!=i?i:n.promises[s].promise}if(e)return e.apply(null,arguments)}]}addHostOnlyFunction(e,t){const o=this;return function(){let t=o.selfPeer.order;for(const e of o.peers.values())t>e.order&&(t=e.order);o.selfPeer.order===t&&e.apply(null,arguments)}}saveStates(){if(this.ws&&this.connecting)for(let[e,t]of this.objectModifications){if(0==t)continue;const o=this.getStateMethods.get(e);if(!o)continue;const s=performance.now();(o.config.maxUpdates&&o.config.maxUpdates<=t||o.config.maxInterval&&o.config.maxInterval<=s-o.lastGet)&&(this.doSendMessage(C({objId:e,state:JSON.stringify(o.method()),revision:this.objectRevisions.get(e)})),o.lastGet=s,this.objectModifications.set(e,0),console.log(`state saved: ${e}`))}}applyInvocation(e,t){return e.apply(null,t)}}return t})()));